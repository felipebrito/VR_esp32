Excelente pergunta! Vou explicar os eventos do Meta Quest/Unity que vocÃª precisa para implementar essa funcionalidade completa.

## ðŸ¥½ Eventos do Meta Quest/Unity para DetecÃ§Ã£o de Status

### **1. Eventos de Headset Wear Detection**

```csharp
using UnityEngine;
using Oculus.Interaction;

public class HeadsetStatusDetector : MonoBehaviour
{
    // Eventos principais do Meta Quest
    void Start()
    {
        // Detectar quando o headset Ã© colocado/removido
        OVRManager.HMDMounted += OnHeadsetMounted;
        OVRManager.HMDUnmounted += OnHeadsetUnmounted;
        
        // Detectar mudanÃ§as de foco da aplicaÃ§Ã£o
        Application.focusChanged += OnApplicationFocusChanged;
        Application.pauseChanged += OnApplicationPauseChanged;
        
        // Detectar mudanÃ§as de conectividade
        Application.backgroundLoadingPriorityChanged += OnBackgroundLoadingChanged;
    }
    
    private void OnHeadsetMounted()
    {
        Debug.Log("Headset colocado - UsuÃ¡rio ONLINE");
        SendToESP32("on1"); // ou "on2" dependendo do player
    }
    
    private void OnHeadsetUnmounted()
    {
        Debug.Log("Headset removido - UsuÃ¡rio OFFLINE");
        SendToESP32("off1"); // Desconectar player
    }
    
    private void OnApplicationFocusChanged(bool hasFocus)
    {
        if (hasFocus)
        {
            Debug.Log("AplicaÃ§Ã£o em foco - UsuÃ¡rio ATIVO");
            SendToESP32("on1");
        }
        else
        {
            Debug.Log("AplicaÃ§Ã£o fora de foco - UsuÃ¡rio INATIVO");
            SendToESP32("pause1");
        }
    }
}
```

### **2. Eventos de Conectividade e Status**

```csharp
public class QuestConnectivityManager : MonoBehaviour
{
    private WebSocketClient wsClient;
    
    void Start()
    {
        // Detectar mudanÃ§as de conectividade WiFi
        NetworkReachability reachability = Application.internetReachability;
        
        // Monitorar status da bateria
        InvokeRepeating("CheckBatteryStatus", 0f, 30f); // A cada 30 segundos
        
        // Monitorar temperatura do headset
        InvokeRepeating("CheckThermalStatus", 0f, 10f); // A cada 10 segundos
    }
    
    private void CheckBatteryStatus()
    {
        float batteryLevel = SystemInfo.batteryLevel;
        if (batteryLevel < 0.1f) // Menos de 10%
        {
            Debug.Log("Bateria baixa - Modo econÃ´mico");
            SendToESP32("lowbattery1");
        }
    }
    
    private void CheckThermalStatus()
    {
        // Verificar se o headset estÃ¡ superaquecendo
        if (OVRManager.instance.isHmdPresent)
        {
            // Headset presente e funcionando
            SendToESP32("on1");
        }
        else
        {
            // Headset nÃ£o detectado
            SendToESP32("off1");
        }
    }
}
```

### **3. Sistema de ComunicaÃ§Ã£o com ESP32**

```csharp
public class ESP32Communication : MonoBehaviour
{
    private WebSocket ws;
    private string esp32IP = "192.168.1.100"; // IP do seu ESP32
    
    void Start()
    {
        ConnectToESP32();
    }
    
    private void ConnectToESP32()
    {
        ws = new WebSocket($"ws://{esp32IP}/ws");
        
        ws.OnOpen += (sender, e) => {
            Debug.Log("Conectado ao ESP32");
            SendPlayerStatus("ready");
        };
        
        ws.OnMessage += (sender, e) => {
            HandleESP32Message(e.Data);
        };
        
        ws.OnClose += (sender, e) => {
            Debug.Log("Desconectado do ESP32");
            // Tentar reconectar
            Invoke("ConnectToESP32", 5f);
        };
        
        ws.Connect();
    }
    
    private void SendPlayerStatus(string status)
    {
        if (ws != null && ws.ReadyState == WebSocketState.Open)
        {
            ws.Send(status);
            Debug.Log($"Enviado para ESP32: {status}");
        }
    }
    
    private void HandleESP32Message(string message)
    {
        Debug.Log($"Recebido do ESP32: {message}");
        
        // Processar comandos do ESP32
        if (message.Contains("play"))
        {
            StartVideoPlayback();
        }
        else if (message.Contains("pause"))
        {
            PauseVideoPlayback();
        }
        else if (message.Contains("stop"))
        {
            StopVideoPlayback();
        }
    }
}
```

### **4. Sistema de Progresso de VÃ­deo**

```csharp
public class VideoProgressManager : MonoBehaviour
{
    private VideoPlayer videoPlayer;
    private bool isPlaying = false;
    
    void Update()
    {
        if (isPlaying && videoPlayer != null)
        {
            // Calcular progresso do vÃ­deo (0-100%)
            float progress = (float)(videoPlayer.time / videoPlayer.length) * 100f;
            int progressInt = Mathf.RoundToInt(progress);
            
            // Enviar progresso para ESP32
            SendProgressToESP32(progressInt);
        }
    }
    
    private void SendProgressToESP32(int progress)
    {
        if (ws != null && ws.ReadyState == WebSocketState.Open)
        {
            string message = $"led1:{progress}";
            ws.Send(message);
        }
    }
    
    private void StartVideoPlayback()
    {
        isPlaying = true;
        videoPlayer.Play();
        Debug.Log("VÃ­deo iniciado");
    }
    
    private void PauseVideoPlayback()
    {
        isPlaying = false;
        videoPlayer.Pause();
        Debug.Log("VÃ­deo pausado");
    }
    
    private void StopVideoPlayback()
    {
        isPlaying = false;
        videoPlayer.Stop();
        SendToESP32("led1:0"); // Apagar LEDs
        Debug.Log("VÃ­deo parado - Modo idle");
    }
}
```

## ðŸŽ¯ **Fluxo Completo de Funcionamento**

### **1. DetecÃ§Ã£o de UsuÃ¡rio Online:**
```
Headset colocado â†’ OVRManager.HMDMounted â†’ SendToESP32("on1") â†’ LEDs piscam verde
```

### **2. InÃ­cio de SessÃ£o:**
```
BotÃ£o pressionado â†’ ESP32 envia "play1" â†’ Unity recebe â†’ StartVideoPlayback()
```

### **3. Progresso do VÃ­deo:**
```
VÃ­deo rodando â†’ Update() calcula progresso â†’ SendProgressToESP32(progress) â†’ LEDs acendem progressivamente
```

### **4. Pausa:**
```
BotÃ£o pressionado â†’ ESP32 envia "pause1" â†’ Unity recebe â†’ PauseVideoPlayback() â†’ LEDs ficam na posiÃ§Ã£o atual
```

### **5. Stop/Idle:**
```
BotÃ£o long press â†’ ESP32 envia "stop1" â†’ Unity recebe â†’ StopVideoPlayback() â†’ LEDs apagam
```

## ðŸ“‹ **Comandos ESP32 â†” Unity**

| Unity â†’ ESP32 | ESP32 â†’ Unity | AÃ§Ã£o |
|---------------|----------------|------|
| `on1` | - | Player 1 online (LEDs piscam verde) |
| `led1:25` | - | Progresso 25% (LEDs acendem) |
| `led1:50` | - | Progresso 50% (LEDs acendem) |
| - | `play1` | Iniciar vÃ­deo |
| - | `pause1` | Pausar vÃ­deo |
| - | `stop1` | Parar vÃ­deo (modo idle) |

## ðŸ”§ **ImplementaÃ§Ã£o Recomendada**

1. **Use `OVRManager.HMDMounted/Unmounted`** para detectar quando o usuÃ¡rio coloca/remove o headset
2. **Use `Application.focusChanged`** para detectar quando a aplicaÃ§Ã£o ganha/perde foco
3. **Implemente WebSocket** para comunicaÃ§Ã£o bidirecional com ESP32
4. **Monitore progresso do vÃ­deo** em tempo real e envie para ESP32
5. **Processe comandos do ESP32** para controlar reproduÃ§Ã£o

Essa implementaÃ§Ã£o te darÃ¡ controle total sobre o status do usuÃ¡rio e sincronizaÃ§Ã£o perfeita entre Unity e ESP32! ðŸš€